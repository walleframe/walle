// Code generated by protoc-gen-gopb. DO NOT EDIT.
// Code generated by wpb. DO NOT EDIT.

package wpb

import (
	"errors"
	"strconv"

	"github.com/aggronmagi/walle/util/protowire"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

// test message
type TestMsg struct {
	// int value
	V1 int32 `json:"v1,omitempty"`
	// string value
	V2 string `json:"v2,omitempty"`
}

func (x *TestMsg) Reset() {
	*x = TestMsg{}
}

// MarshalObject marshal data to []byte
func (x *TestMsg) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *TestMsg) MarshalSize() (size int) {
	if x.V1 != 0 {
		// 1 = protowire.SizeTag(1)
		size += 1 + protowire.SizeVarint(uint64(x.V1))
	}
	if len(x.V2) > 0 {
		// 1 = protowire.SizeTag(2)
		size += 1 + protowire.SizeBytes(len(x.V2))
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *TestMsg) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.V1 != 0 {
		// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
		data = append(data, 0x8)
		data = protowire.AppendVarint(data, uint64(x.V1))
	}
	if len(x.V2) > 0 {
		// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
		data = append(data, 0x12)
		data = protowire.AppendString(data, x.V2)
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *TestMsg) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse TestMsg.V1 ID:1 : invalid varint value")
				return
			}
			index += cnt
			x.V1 = int32(v)
		case 2:
			v, cnt := protowire.ConsumeString(data[index:])
			if cnt < 1 {
				err = errors.New("parse TestMsg.V2 ID:2 : invalid len value")
				return
			}
			index += cnt
			x.V2 = v
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *TestMsg) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("V1", x.V1)
	enc.AddString("V2", x.V2)
	return nil
}

type ZapArrayTestMsg []*TestMsg

func (x ZapArrayTestMsg) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayTestMsg(name string, v []*TestMsg) zap.Field {
	return zap.Array(name, ZapArrayTestMsg(v))
}

// multiply rq
type MulRq struct {
	// mul a
	A int32 `json:"a,omitempty"`
	// mul b
	B int32 `json:"b,omitempty"`
}

func (x *MulRq) Reset() {
	*x = MulRq{}
}

// MarshalObject marshal data to []byte
func (x *MulRq) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *MulRq) MarshalSize() (size int) {
	if x.A != 0 {
		// 1 = protowire.SizeTag(1)
		size += 1 + protowire.SizeVarint(uint64(x.A))
	}
	if x.B != 0 {
		// 1 = protowire.SizeTag(2)
		size += 1 + protowire.SizeVarint(uint64(x.B))
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *MulRq) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.A != 0 {
		// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
		data = append(data, 0x8)
		data = protowire.AppendVarint(data, uint64(x.A))
	}
	if x.B != 0 {
		// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
		data = append(data, 0x10)
		data = protowire.AppendVarint(data, uint64(x.B))
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *MulRq) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse MulRq.A ID:1 : invalid varint value")
				return
			}
			index += cnt
			x.A = int32(v)
		case 2:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse MulRq.B ID:2 : invalid varint value")
				return
			}
			index += cnt
			x.B = int32(v)
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *MulRq) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("A", x.A)
	enc.AddInt32("B", x.B)
	return nil
}

type ZapArrayMulRq []*MulRq

func (x ZapArrayMulRq) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayMulRq(name string, v []*MulRq) zap.Field {
	return zap.Array(name, ZapArrayMulRq(v))
}

// multiply result
type MulRs struct {
	// mul result
	R int32 `json:"r,omitempty"`
}

func (x *MulRs) Reset() {
	*x = MulRs{}
}

// MarshalObject marshal data to []byte
func (x *MulRs) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *MulRs) MarshalSize() (size int) {
	if x.R != 0 {
		// 1 = protowire.SizeTag(1)
		size += 1 + protowire.SizeVarint(uint64(x.R))
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *MulRs) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.R != 0 {
		// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
		data = append(data, 0x8)
		data = protowire.AppendVarint(data, uint64(x.R))
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *MulRs) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse MulRs.R ID:1 : invalid varint value")
				return
			}
			index += cnt
			x.R = int32(v)
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *MulRs) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("R", x.R)
	return nil
}

type ZapArrayMulRs []*MulRs

func (x ZapArrayMulRs) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayMulRs(name string, v []*MulRs) zap.Field {
	return zap.Array(name, ZapArrayMulRs(v))
}

// add request
type AddRq struct {
	// add params
	Params []int64 `json:"params,omitempty"`
}

func (x *AddRq) Reset() {
	*x = AddRq{}
}

// MarshalObject marshal data to []byte
func (x *AddRq) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *AddRq) MarshalSize() (size int) {
	if len(x.Params) > 0 {
		// 1 = protowire.SizeTag(1)
		size += 1 * len(x.Params)
		for k := 0; k < len(x.Params); k++ {
			size += protowire.SizeVarint(uint64(x.Params[k]))
		}
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *AddRq) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if len(x.Params) > 0 {
		for _, item := range x.Params {
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(item))
		}
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *AddRq) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse AddRq.Params ID:1 : invalid varint value")
					return
				}
				x.Params = append(x.Params, int64(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse AddRq.Params ID:1 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse AddRq.Params ID:1 : invalid len value")
				return
			}
			index += cnt
			if x.Params == nil {
				x.Params = make([]int64, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse AddRq.Params ID:1 : invalid item value")
					return
				}
				sub += cnt
				x.Params = append(x.Params, int64(v))
			}
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *AddRq) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddArray("Params", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.Params {
			ae.AppendInt64(v)
		}
		return nil
	}))
	return nil
}

type ZapArrayAddRq []*AddRq

func (x ZapArrayAddRq) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayAddRq(name string, v []*AddRq) zap.Field {
	return zap.Array(name, ZapArrayAddRq(v))
}

// add reply
type AddRs struct {
	// add result
	Value int64 `json:"value,omitempty"`
}

func (x *AddRs) Reset() {
	*x = AddRs{}
}

// MarshalObject marshal data to []byte
func (x *AddRs) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *AddRs) MarshalSize() (size int) {
	if x.Value != 0 {
		// 1 = protowire.SizeTag(1)
		size += 1 + protowire.SizeVarint(uint64(x.Value))
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *AddRs) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.Value != 0 {
		// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
		data = append(data, 0x8)
		data = protowire.AppendVarint(data, uint64(x.Value))
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *AddRs) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse AddRs.Value ID:1 : invalid varint value")
				return
			}
			index += cnt
			x.Value = int64(v)
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *AddRs) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt64("Value", x.Value)
	return nil
}

type ZapArrayAddRs []*AddRs

func (x ZapArrayAddRs) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayAddRs(name string, v []*AddRs) zap.Field {
	return zap.Array(name, ZapArrayAddRs(v))
}

type ANtf struct {
	F1 map[int32]int32 `json:"f1,omitempty"`
}

func (x *ANtf) Reset() {
	*x = ANtf{}
}

// MarshalObject marshal data to []byte
func (x *ANtf) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *ANtf) MarshalSize() (size int) {
	if len(x.F1) > 0 {
		for mk, mv := range x.F1 {
			_ = mk
			_ = mv
			// 1 = protowire.SizeTag(1)
			size += 1
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *ANtf) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if len(x.F1) > 0 {
		for mk, mv := range x.F1 {
			// data = protowire.AppendTag(data, 1, protowire.BytesType) => 00001010
			data = append(data, 0xa)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *ANtf) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			if typ != protowire.BytesType {
				err = errors.New("parse ANtf.F1 ID:1 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse ANtf.F1 ID:1 : invalid len value")
				return
			}
			index += cnt
			if x.F1 == nil {
				x.F1 = make(map[int32]int32)
			}
			var mk int32
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse ANtf.F1 ID:1 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse ANtf.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = int32(v)
				case 2:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse ANtf.Value ID:2 : invalid varint value")
						return
					}
					sindex += cnt
					mv = int32(v)
				}
			}
			x.F1[mk] = mv
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *ANtf) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddObject("F1", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.F1 {
			oe.AddInt32(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	return nil
}

type ZapArrayANtf []*ANtf

func (x ZapArrayANtf) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayANtf(name string, v []*ANtf) zap.Field {
	return zap.Array(name, ZapArrayANtf(v))
}

type BNtf struct {
	F1 *ANtf   `json:"f1,omitempty"`
	F2 []*ANtf `json:"f2,omitempty"`
}

func (x *BNtf) Reset() {
	*x = BNtf{}
}

// MarshalObject marshal data to []byte
func (x *BNtf) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *BNtf) MarshalSize() (size int) {
	if x.F1 != nil {
		// 1 = protowire.SizeTag(1)
		size += 1 + protowire.SizeBytes(x.F1.MarshalSize())
	}
	if x.F2 != nil {
		// 1 = protowire.SizeTag(2)
		size += 1 * len(x.F2)
		for k := 0; k < len(x.F2); k++ {
			size += protowire.SizeBytes(x.F2[k].MarshalSize())
		}
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *BNtf) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.F1 != nil {
		// data = protowire.AppendTag(data, 1, protowire.BytesType) => 00001010
		data = append(data, 0xa)
		data = protowire.AppendVarint(data, uint64(x.F1.MarshalSize()))
		data, err = x.F1.MarshalObjectTo(data)
		if err != nil {
			return
		}
	}
	if x.F2 != nil {
		for _, item := range x.F2 {
			// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
			data = append(data, 0x12)
			data = protowire.AppendVarint(data, uint64(item.MarshalSize()))
			data, err = item.MarshalObjectTo(data)
			if err != nil {
				return
			}
		}
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *BNtf) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			v, cnt := protowire.ConsumeBytes(data[index:])
			if v == nil {
				err = errors.New("parse BNtf.F1 ID:1 : invalid message value")
				return
			}
			index += cnt
			x.F1 = &ANtf{}
			err = x.F1.UnmarshalObject(v)
			if err != nil {
				return
			}
		case 2:
			if typ != protowire.BytesType {
				err = errors.New("parse BNtf.F2 ID:2 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse BNtf.F2 ID:2 : invalid len value")
				return
			}
			index += cnt
			if x.F2 == nil {
				x.F2 = make([]*ANtf, 0, 2)
			}
			item := &ANtf{}
			err = item.UnmarshalObject(buf)
			if err != nil {
				return
			}
			x.F2 = append(x.F2, item)
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *BNtf) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddObject("F1", x.F1)
	enc.AddArray("F2", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.F2 {
			ae.AppendObject(v)
		}
		return nil
	}))
	return nil
}

type ZapArrayBNtf []*BNtf

func (x ZapArrayBNtf) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayBNtf(name string, v []*BNtf) zap.Field {
	return zap.Array(name, ZapArrayBNtf(v))
}
